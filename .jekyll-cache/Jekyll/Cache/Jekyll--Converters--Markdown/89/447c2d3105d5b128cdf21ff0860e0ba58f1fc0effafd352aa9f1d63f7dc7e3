I"v0<h1 class="no_toc" id="tutorial">Tutorial</h1>
<p class="fs-6 fw-300">A step-by-step guide to using Hydra</p>

<h2 class="no_toc text-delta" id="table-of-contents">Table of contents</h2>

<ol id="markdown-toc">
  <li><a href="#basics" id="markdown-toc-basics">Basics</a>    <ol>
      <li><a href="#hilbertspaces-and-blocks" id="markdown-toc-hilbertspaces-and-blocks">Hilbertspaces and blocks</a></li>
      <li><a href="#operators" id="markdown-toc-operators">Operators</a></li>
      <li><a href="#linear-algebra" id="markdown-toc-linear-algebra">Linear Algebra</a></li>
    </ol>
  </li>
</ol>

<hr />

<h2 id="basics">Basics</h2>

<p>The central ingredients of quantum mechanics are Hilbert spaces, symmetries, operators, and linear algebra. In these first introductory chapters, we will discuss how these concepts are implemented in Hydra, and how to perform a first exact diagonalization.</p>

<hr />

<h3 id="hilbertspaces-and-blocks">Hilbertspaces and blocks</h3>
<p>A physical system is typically described by a Hamiltonian operator acting on a Hilbert space. In this introductory material we will consider a simple example, the spin-\(1/2\) Heisenberg model on a periodic chain lattice. Itâ€™s Hilbert space \(\mathcal{H}\) is the tensor product of local spins \(\sigma_i = \uparrow,\downarrow\) on a lattice,</p>

\[\mathcal{H} = \bigotimes_{i=1}^N \text{span}_{\mathbb{C}}\left( |\uparrow\rangle_i, |\downarrow \rangle_i \right),\]

<p>whose dimension grows exponentially with the number of lattice sites \(N\), \(\text{dim}(\mathcal{H}) = 2^N\). The Hamiltonian is given by,</p>

\[H = J \sum_{\langle i,j \rangle}  \vec{S}_i \cdot \vec{S}_j.\]

<p>Here, \(\vec{S}_i = (S^x_i, S^y_i, S^z_i)\) denotes the spin operators on site \(i\), and the sum \(\langle i,j \rangle\) denotes the sum over nearest-neighbors \(i,j\) on the lattice. Upon choosing a basis \(\vert n \rangle\) of \(\mathcal{H}\) we can compute the matrix elements of \(H_{mn} = \langle m \vert H \vert n \rangle\). In Hydra, we typically work in a basis of product states,</p>

\[\vert \mathbf{\sigma} \rangle = \vert \sigma_1 \rangle \cdots \vert \sigma_N \rangle.\]

<p>Representing the Hamiltonian \(H\) in this basis will yield a sparse matrix, whose non-zero matrix elements are distributed something like this:</p>

<center>
<img src="/assets/images/block.png" width="200" />
</center>

<p>Symmetries of \(H\) are operators \(S\), which commute with the Hamiltonian \([H,S] = 0\). We can choose a basis of the Hilbert space such that every state transforms according to an irreducible representation \(\rho\), also called quantum numbers, of the group of symmetries. If we express the Hamiltonian in this basis, it will attain a block diagonal form,</p>

<center>
<img src="/assets/images/block_decomp.png" width="500" />
</center>

<p>For the Heisenberg chain above, the symmetries include the continuous \(U(1)\) spin rotation symmetry,</p>

\[S(\theta) = \text{exp}\left[ -i \theta \sum_{i=1}^N S_i^z\right]\]

<p>The irreducible representations \(\rho\) are labeled by \(S^z_{\text{tot}} = \sum_{i=1}^N S_i^z\). Another symmetry of the Heisenberg chain is the discrete translational symmetry,</p>

\[T \vert \sigma_1 \sigma_2 \cdots \sigma_{N-1} \sigma_{N}\rangle \rightarrow \vert \sigma_N \sigma_1 \cdots \sigma_{N-2} \sigma_{N-1}\rangle\]

<p>The irreducible representations then correspond to the discrete lattice momenta.</p>

<p>The subspaces \(\mathcal{H}_\rho\) of the full Hilbert space \(\mathcal{H}\) are central object in Hydra, and are called <strong>blocks</strong>. To create a block object of a model with spin-\(1/2\) degrees of freedom, living on \(N\) sites, with a given \(S^z_{\text{tot}}\), we use</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n_sites</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n_up</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">block</span> <span class="o">=</span> <span class="n">Spinhalf</span><span class="p">(</span><span class="n">n_sites</span><span class="p">,</span> <span class="n">n_up</span><span class="p">);</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">n_sites</code> denotes the number of lattice sites \(N=8\) and <code class="language-plaintext highlighter-rouge">n_up</code> is the number \(n_\uparrow=4\) of \(\uparrow\)-electrons, so \(S^z_{\text{tot}} = \frac{1}{2}(n_\uparrow - n_\downarrow)=0\).</p>

<p>Besides the <a href="../../docs/Spinhalf3Cbit_t3E/index.html">Spinhalf</a> block, Hydra also features an <a href="../../docs/Electron3Cbit_t3E/index.html">Electron</a> block, which implements lattice spin-\(1/2\) fermions, and a <a href="../../docs/tJ3Cbit_t3E/index.html">tJ</a> block, implementing \(t-J\)-like models of spin-\(1/2\) fermions with a double-occupancy constraint.</p>

<p>We will see in a later chapter, how to employ space group, or lattice site permutation symmetries in Hydra. In this case, the blocks <a href="../../docs/SpinhalfSymmetric3Cbit_.a252e6ff/index.html">SpinhalfSymmetric</a>, <a href="../../docs/ElectronSymmetric3Cbit_.a47e0fb2/index.html">ElectronSymmetric</a>, and <a href="../../docs/tJSymmetric3Cbit_t2C20G.33db605a/index.html">tJSymmetric</a> can be used. There are also specialized blocks with distributed memory parallelization, <a href="../../docs/SpinhalfMPI3Cbit_t3E/index.html">SpinhalfMPI</a>, and <a href="../../docs/ElectronMPI3Cbit_t3E/index.html">ElectronMPI</a>.</p>

<hr />

<h3 id="operators">Operators</h3>

<p>Any physical observable is represented by an operator \(O\), which is a mapping,</p>

\[O: \mathcal{H}_{\rho_{\text{in}}} \mapsto \mathcal{H}_{\rho_{\text{out}}}.\]

<p>Let us extend our previous example o the Heisenberg spin-\(1/2\) chain to feature also second-nearest neighbor interactions,</p>

\[H = J_1 \sum_{\langle i,j \rangle}  \vec{S}_i \cdot \vec{S}_j + J_2\sum_{\langle\langle i,j \rangle\rangle}  \vec{S}_i \cdot \vec{S}_j.\]

<p>Here \(\langle \langle \cdots \rangle\rangle\) denotes the sum over second nearest-neighbors. A single term in an operator, like the exchange interaction \(\vec{S}_1 \cdot \vec{S}_2\) between site \(1\) and \(2\), is represented by an object called a <a href="../../docs/Bond/index.html">Bond</a> in hydra. To create a single bond, we need three pieces of information:</p>

<ul>
  <li>The <strong>type</strong> of the bond. This is an <code class="language-plaintext highlighter-rouge">std::string</code>, which is just a label for the kind of interaction. For exchange interactions \(\vec{S}_i \cdot \vec{S}_j\) Hydra typically uses the type <code class="language-plaintext highlighter-rouge">"HB"</code>.</li>
  <li>The <strong>coupling</strong> of the bond. This is also an <code class="language-plaintext highlighter-rouge">std::string</code>, which gives a name to the coupling constant of the bond. In the \(J_1\)-\(J_2\) model above, this could be <code class="language-plaintext highlighter-rouge">J1</code> or <code class="language-plaintext highlighter-rouge">J2</code></li>
  <li>The <strong>sites</strong> the bond lives on. This is an <code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code>, which stores the site numbers, starting to count from <code class="language-plaintext highlighter-rouge">0</code>.</li>
</ul>

<p>For example, a nearest-neighbor bond \(J_1\vec{S}_1 \cdot \vec{S}_2\) is created using,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">bond</span> <span class="o">=</span> <span class="n">Bond</span><span class="p">(</span><span class="s">"HB"</span><span class="p">,</span> <span class="s">"J1"</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">});</span>
</code></pre></div></div>

<p>To represent a full operator with multiple bonds, we use a <a href="../../docs/BondList/index.html">BondList</a>. A <code class="language-plaintext highlighter-rouge">BondList</code> is a convenient container for bonds. The Hamiltonian of the \(J_1\)-\(J_2\) model is created using the following code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BondList</span> <span class="n">bonds</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">n_sites</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bonds</span> <span class="o">&lt;&lt;</span> <span class="n">Bond</span><span class="p">(</span><span class="s">"HB"</span><span class="p">,</span> <span class="s">"J1"</span><span class="p">,</span> <span class="p">{</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_sites</span><span class="p">});</span>
  <span class="n">bonds</span> <span class="o">&lt;&lt;</span> <span class="n">Bond</span><span class="p">(</span><span class="s">"HB"</span><span class="p">,</span> <span class="s">"J2"</span><span class="p">,</span> <span class="p">{</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">n_sites</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>While a <code class="language-plaintext highlighter-rouge">BondList</code> object defines the (multi)graph of interactions, it does not contain information about the numerical value of the coupling constants, like \(J_1\) and \(J_2\) above. Coupling constants are defined in a separate object called <a href="../../docs/Couplings/index.html">Couplings</a>, which is basically an <code class="language-plaintext highlighter-rouge">std::map&lt;std::string, std::complex&lt;double&gt;&gt;</code> with some additional features. We can set the coupling strengths using,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Couplings</span> <span class="n">couplings</span><span class="p">;</span>
<span class="n">couplings</span><span class="p">[</span><span class="s">"J1"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="n">couplings</span><span class="p">[</span><span class="s">"J2"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</code></pre></div></div>

<p>Finally, we are in the position to create a matrix of our operator by using a function called <a href="../../docs/f_MatrixReal/index.html">MatrixReal</a>. It creates a double-precision real matrix of the operator defined by a <code class="language-plaintext highlighter-rouge">BondList</code> and <code class="language-plaintext highlighter-rouge">Couplings</code>, mapping from one block to another. In our case, the Hamiltonian maps each quantum number block onto itself. We can, therefore, get a matrix of the Hamiltonian by,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">H</span> <span class="o">=</span> <span class="n">MatrixReal</span><span class="p">(</span><span class="n">bonds</span><span class="p">,</span> <span class="n">couplings</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</code></pre></div></div>

<p>There also exists <a href="../../docs/f_MatrixCplx/index.html">MatrixCplx</a>, which is used if we expect our operator to have complex coefficients.</p>

<h3 id="linear-algebra">Linear Algebra</h3>
:ET